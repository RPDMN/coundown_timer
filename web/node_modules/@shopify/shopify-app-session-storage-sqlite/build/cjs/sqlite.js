'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var shopifyApi = require('@shopify/shopify-api');
var sqliteConnection = require('./sqlite-connection.js');
var migrations = require('./migrations.js');
var sqliteMigrator = require('./sqlite-migrator.js');

const defaultSQLiteSessionStorageOptions = {
  sessionTableName: 'shopify_sessions',
  migratorOptions: {
    migrationDBIdentifier: 'shopify_sessions_migrations',
    migrationNameColumnName: 'migration_name',
    migrations: migrations.migrationList
  }
};
class SQLiteSessionStorage {
  constructor(filename, opts = {}) {
    this.options = void 0;
    this.db = void 0;
    this.ready = void 0;
    this.internalInit = void 0;
    this.migrator = void 0;
    this.options = {
      ...defaultSQLiteSessionStorageOptions,
      ...opts
    };
    this.db = new sqliteConnection.SqliteConnection(filename, this.options.sessionTableName);
    this.internalInit = this.init();
    this.ready = this.initMigrator(this.options.migratorOptions);
  }
  async storeSession(session) {
    await this.ready;

    // Note milliseconds to seconds conversion for `expires` property
    const entries = session.toPropertyArray().map(([key, value]) => key === 'expires' ? [key, Math.floor(value / 1000)] : [key, value]);
    const query = `
      INSERT OR REPLACE INTO ${this.options.sessionTableName}
      (${entries.map(([key]) => key).join(', ')})
      VALUES (${entries.map(() => `${this.db.getArgumentPlaceholder()}`).join(', ')});
    `;
    await this.db.query(query, entries.map(([_key, value]) => value));
    return true;
  }
  async loadSession(id) {
    await this.ready;
    const query = `
      SELECT * FROM ${this.options.sessionTableName}
      WHERE id = ${this.db.getArgumentPlaceholder()};
    `;
    const rows = await this.db.query(query, [id]);
    if (!Array.isArray(rows) || (rows === null || rows === void 0 ? void 0 : rows.length) !== 1) return undefined;
    const rawResult = rows[0];
    return this.databaseRowToSession(rawResult);
  }
  async deleteSession(id) {
    await this.ready;
    const query = `
      DELETE FROM ${this.options.sessionTableName}
      WHERE id = ${this.db.getArgumentPlaceholder()};
    `;
    await this.db.query(query, [id]);
    return true;
  }
  async deleteSessions(ids) {
    await this.ready;
    const query = `
      DELETE FROM ${this.options.sessionTableName}
      WHERE id IN (${ids.map(() => `${this.db.getArgumentPlaceholder()}`).join(',')});
    `;
    await this.db.query(query, ids);
    return true;
  }
  async findSessionsByShop(shop) {
    await this.ready;
    const query = `
      SELECT * FROM ${this.options.sessionTableName}
      WHERE shop = ${this.db.getArgumentPlaceholder()};
    `;
    const rows = await this.db.query(query, [shop]);
    if (!Array.isArray(rows) || (rows === null || rows === void 0 ? void 0 : rows.length) === 0) return [];
    const results = rows.map(row => {
      return this.databaseRowToSession(row);
    });
    return results;
  }
  async init() {
    const hasSessionTable = await this.db.hasTable(this.options.sessionTableName);
    if (!hasSessionTable) {
      const query = `
        CREATE TABLE ${this.options.sessionTableName} (
          id varchar(255) NOT NULL PRIMARY KEY,
          shop varchar(255) NOT NULL,
          state varchar(255) NOT NULL,
          isOnline integer NOT NULL,
          expires integer,
          scope varchar(1024),
          accessToken varchar(255),
          onlineAccessInfo varchar(255)
        );
      `;
      await this.db.query(query);
    }
  }
  databaseRowToSession(row) {
    // convert seconds to milliseconds prior to creating Session object
    if (row.expires) row.expires *= 1000;
    return shopifyApi.Session.fromPropertyArray(Object.entries(row));
  }
  async initMigrator(migratorOptions) {
    await this.internalInit;
    if (migratorOptions === null) {
      return Promise.resolve();
    } else {
      this.migrator = new sqliteMigrator.SqliteSessionStorageMigrator(this.db, migratorOptions);
      this.migrator.validateMigrationList(migrations.migrationList);
      return this.migrator.applyMigrations();
    }
  }
}

exports.SQLiteSessionStorage = SQLiteSessionStorage;
